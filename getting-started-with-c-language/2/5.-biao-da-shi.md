# 5. 表达式

常量和变量都可以参与加减乘除运算，例如`1+1`、`hour-1`、`hour * 60 + minute`、`minute/60`等。这里的+ - \* /称为运算符（Operator），而参与运算的常量和变量称为操作数（Operand），上面四个由运算符和操作数所组成的算式称为表达式（Expression）。

和数学上规定的一样，`hour * 60 + minute`这个表达式应该先算乘再算加，也就是说运算符是有优先级（Precedence）的，\*和/是同一优先级，+和-是同一优先级，\*和/的优先级高于+和-。对于同一优先级的运算从左到右计算，如果不希望按默认的优先级计算则要加()括号（Parenthesis）。例如`(3+4)*5/6`应先算3+4，再算\*5，再算/6。

前面讲过打印语句和赋值语句，现在我们定义：在任意表达式后面加个;号也是一种语句，称为表达式语句。例如：

```c
hour * 60 + minute;
```

这是个合法的语句，但这个语句在程序中起不到任何作用，把hour的值和minute的值取出来加乘，得到的计算结果却没有保存，白算了一通。再比如：

```c
int total_minute;
total_minute = hour * 60 + minute;
```

这个语句就很有意义，把计算结果保存在另一个变量`total_minute`里。事实上等号也是一种运算符，称为赋值运算符，赋值语句就是一种表达式语句，等号的优先级比+和\*都低，所以先算出等号右边的结果然后才做赋值操作，整个表达式`total_minute = hour * 60 + minute`加个;号构成一个语句。

_任何表达式都有值和类型两个基本属性_。`hour * 60 + minute`的值是由三个`int`型的操作数计算出来的，所以这个表达式的类型也是`int`型。同理，表达式`total_minute = hour * 60 + minute`的类型也是`int`，它的值是多少呢？C语言规定等号运算符的计算结果就是等号左边被赋予的那个值，所以这个表达式的值和`hour * 60 + minute`的值相同，也和`total_minute`的值相同。

等号运算符还有一个和+ - \* /不同的特性，如果一个表达式中出现多个等号，不是从左到右计算而是从右到左计算，例如：

```c
int total_minute, total;
total = total_minute = hour * 60 + minute;
```

计算顺序是先算`hour * 60 + minute`得到一个结果，然后算右边的等号，就是把`hour * 60 + minute`的结果赋给变量`total_minute`，这个结果同时也是整个表达式`total_minute = hour * 60 + minute`的值，再算左边的等号，即把这个值再赋给变量`total`。同样优先级的运算符是从左到右计算还是从右到左计算称为运算符的结合性（Associativity）。+ - \* /是左结合的，等号是右结合的。

现在我们总结一下到目前为止学过的语法规则：

表达式 → 标识符\
表达式 → 常量\
表达式 → 字符串字面值\
表达式 → (表达式)\
表达式 → 表达式 + 表达式\
表达式 → 表达式 - 表达式\
表达式 → 表达式 \* 表达式\
表达式 → 表达式 / 表达式\
表达式 → 表达式 = 表达式\
语句 → 表达式;\
语句 → printf(表达式, 表达式, 表达式, ...);\
变量声明 → 类型 标识符 = Initializer, 标识符 = Initializer, ...;\
（= Initializer的部分可以不写）

注意，_本书所列的语法规则都是简化过的，是不准确的，目的是为了便于初学者理解_，比如上面所列的语法规则并没有描述运算符的优先级和结合性。完整的C语法规则请参考[\[C99\]](https://akaedu.github.io/book/bi01.html#bibli.c99)的Annex A。

表达式可以是单个的常量或变量，也可以是根据以上规则组合而成的更复杂的表达式。以前我们用`printf`打印常量或变量的值，现在可以用`printf`打印更复杂的表达式的值，例如：

```c
printf("%d:%d is %d minutes after 00:00\n", hour, minute, hour * 60 + minute);
```

编译器在翻译这条语句时，首先根据上述语法规则把这个语句解析成下图所示的语法树，然后再根据语法树生成相应的指令。语法树的末端的是一个个Token，每一步展开利用一条语法规则。

**图 2.2. 语法树**

![语法树](https://akaedu.github.io/book/images/expr.parse.png)\


根据这些语法规则进一步组合可以写出更复杂的语句，比如在一条语句中完成计算、赋值和打印功能：

```c
printf("%d:%d is %d minutes after 00:00\n", hour, minute, total_minute = hour * 60 + minute);
```

理解组合（Composition）规则是理解语法规则的关键所在，正因为可以根据语法规则任意组合，我们才可以用简单的常量、变量、表达式、语句搭建出任意复杂的程序，以后我们学习新的语法规则时会进一步体会到这一点。从上面的例子可以看出，表达式不宜过度组合，否则会给阅读和调试带来困难。

根据语法规则组合出来的表达式在语义上并不总是正确的，例如：

```c
minute + 1 = hour;
```

等号左边的表达式要求表示一个存储位置而不是一个值，这是等号运算符和+ - \* /运算符的又一个显著不同。有的表达式既可以表示一个存储位置也可以表示一个值，而有的表达式只能表示值，不能表示存储位置，例如`minute + 1`这个表达式就不能表示存储位置，放在等号左边是语义错误。表达式所表示的存储位置称为左值（lvalue）（允许放在等号左边），而以前我们所说的表达式的值也称为右值（rvalue）（只能放在等号右边）。上面的话换一种说法就是：_有的表达式既可以做左值也可以做右值，而有的表达式只能做右值_。目前我们学过的表达式中只有变量可以做左值，可以做左值的表达式还有几种，以后会讲到。

我们看一个有意思的例子，如果定义三个变量`int a, b, c;`，表达式`a = b = c`是合法的，先求`b = c`的值，再把这个值赋给`a`，而表达式`(a = b) = c`是不合法的，先求`(a = b)`的值没问题，但`(a = b)`这个表达式不能再做左值了，因此放在`= c`的等号左边是错的。

关于整数除法运算有一点特殊之处：

```c
hour = 11;
minute = 59;
printf("%d and %d hours\n", hour, minute / 60);
```

执行结果是`11 and 0 hours`，也就是说59/60得0，这是因为两个`int`型操作数相除的表达式仍为`int`型，只能保存计算结果的整数部分，即使小数部分是0.98也要舍去。

向下取整的运算称为Floor，用数学符号⌊⌋表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。例如：

⌊59/60⌋=0\
⌈59/60⌉=1\
⌊-59/60⌋=-1\
⌈-59/60⌉=0

在C语言中整数除法取的既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截掉，在数轴上向零的方向取整（Truncate toward Zero），或者说当操作数为正的时候相当于Floor，当操作符为负的时候相当于Ceiling。回到先前的例子，要得到更精确的结果可以这样：

```c
printf("%d hours and %d percent of an hour\n", hour, minute * 100 / 60);
printf("%d and %f hours\n", hour, minute / 60.0);
```

在第二个`printf`中，表达式是`minute / 60.0`，60.0是`double`型的，/运算符要求左右两边的操作数类型一致，而现在并不一致。C语言规定了一套隐式类型转换规则，在这里编译器自动把左边的`minute`也转成`double`型来计算，整个表达式的值也是`double`型的，在格式化字符串中应该用`%f`转换说明与之对应。本来编程语言作为一种形式语言要求有简单而严格的规则，自动类型转换规则不仅很复杂，而且使C语言的形式看起来也不那么严格了，C语言这么设计是为了书写程序简便而做的折衷，有些事情编译器可以自动做好，程序员就不必每次都写一堆繁琐的转换代码。然而C语言的类型转换规则非常难掌握，本书的前几章会尽量避免类型转换，到[第 3 节 “类型转换”](https://akaedu.github.io/book/ch15s03.html#type.conversion)再集中解决这个问题。

#### 习题

1、假设变量`x`和`n`是两个正整数，我们知道`x/n`这个表达式的结果要取Floor，例如`x`是17，`n`是4，则结果是4。如果希望结果取Ceiling应该怎么写表达式呢？例如`x`是17，`n`是4，则结果是5；`x`是16，`n`是4，则结果是4。
